# 미니 2차 프로젝트 가이드 (상세버전)

## 목차
1. [BackEnd 설계 가이드]
2. [FrontEnd 설계 가이드]
3. [프로젝트 작성 순서 및 9일 타임테이블]
4. [프로젝트 평가 및 배점표]

---

## 1. BackEnd 설계 가이드

### 1.1 도메인 설계서 가이드

#### 1.1.1 도메인 설계의 중요성
도메인 설계는 비즈니스 요구사항을 기술적 구현으로 연결하는 핵심 단계입니다. 올바른 도메인 설계는 코드의 가독성, 유지보수성, 확장성을 크게 향상시킵니다.

#### 1.1.2 작성 단계별 가이드

**STEP 1: 비즈니스 도메인 분석**
- 프로젝트의 핵심 비즈니스 목적 정의
- 주요 이해관계자(Stakeholder) 식별
- 비즈니스 프로세스 흐름 파악

**예시: 온라인 도서관 시스템**
```
비즈니스 목적: 도서 대출/반납 관리 및 회원 관리
주요 이해관계자: 도서관 관리자, 회원, 사서
핵심 프로세스: 회원가입 → 도서검색 → 대출신청 → 승인 → 반납
```

**STEP 2: 핵심 도메인 객체 식별**
- 비즈니스에서 중요한 명사들을 찾아 도메인 객체로 정의합니다.

```
핵심 도메인 객체:
1. 회원 (Member)
   - 속성: 회원번호, 이름, 이메일, 전화번호, 가입일
   - 역할: 도서 대출 및 반납 주체

2. 도서 (Book)
   - 속성: ISBN, 제목, 저자, 출판사, 카테고리, 재고수량
   - 역할: 대출 대상

3. 대출 (Loan)
   - 속성: 대출번호, 대출일, 반납예정일, 실제반납일, 상태
   - 역할: 회원과 도서 간의 대출 관계

4. 카테고리 (Category)
   - 속성: 카테고리ID, 카테고리명, 설명
   - 역할: 도서 분류

5. 관리자 (Admin)
   - 속성: 관리자ID, 이름, 권한레벨
   - 역할: 시스템 관리 및 대출 승인
```

**STEP 3: 도메인 관계 정의**
- 객체 간의 관계를 명확히 정의합니다.

```
도메인 관계:
- 회원 (1) : 대출 (N) - 한 회원은 여러 책을 대출할 수 있음
- 도서 (1) : 대출 (N) - 한 책은 여러 번 대출될 수 있음
- 카테고리 (1) : 도서 (N) - 한 카테고리에 여러 책이 속함
- 관리자 (1) : 대출승인 (N) - 한 관리자가 여러 대출을 승인
```

**STEP 4: Business 규칙 정의**
- 비즈니스 규칙:

```
1. 회원은 최대 5권까지 동시 대출 가능
2. 대출 기간은 기본 14일
3. 연체 시 연체료 발생 (1일당 100원)
4. 연체 중인 회원은 추가 대출 불가
5. 재고가 0인 도서는 대출 불가
6. 관리자만 회원 정보 수정 및 대출 강제 반납 가능
```

**STEP 5: 용어 정의서 작성**
- 용어에 대한 정의:

```
- 대출가능도서: 재고 수량이 1 이상인 도서
- 연체: 반납예정일을 초과한 미반납 상태
- 활성회원: 가입 후 인증이 완료된 회원
- 대출이력: 과거 대출했던 모든 기록
- 예약: 현재 대출 불가능한 도서에 대한 우선 대출 신청
```

#### 1.1.3 도메인 설계서 템플릿

```markdown
# 도메인 설계서

## 1. 프로젝트 개요
- 프로젝트명: 
- 도메인 영역: 
- 핵심 비즈니스: 

## 2. 핵심 도메인 객체
### 2.1 [객체명]
- 설명: 
- 주요 속성: 
- 주요 행위: 
- 비즈니스 규칙: 

## 3. 도메인 관계도
[시각적 다이어그램 또는 설명]

## 4. 비즈니스 규칙
1. 
2. 
3. 

## 5. 용어 정의
- 용어1: 정의
- 용어2: 정의
```

### 1.2 Entity 설계서 가이드

#### 1.2.1 Entity 설계 원칙

**1. 단일 책임 원칙**
- 하나의 Entity는 하나의 비즈니스 개념만 표현
- 관련없는 속성들을 하나의 Entity에 포함하지 않음

**2. 적절한 식별자 설계**
- 자연키(Natural Key) vs 대리키(Surrogate Key) 선택 기준 명확히
- UUID vs Auto Increment 선택 근거
- 대리키(Surrogate Key)를 사용하는 이유
  * 안정성: 비즈니스 규칙이  바뀌어도 PK는 변경되지 않음
  * 성능: 정수형이 문자열보다 빠름
  * 확장성: 향후 요구사항 변경에 유연

```java
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;                    // 대리키 (Primary Key)
    
    @Column(unique = true, nullable = false)
    private String memberNumber;        // 비즈니스 키 (자연키 후보)
    
    @Column(unique = true, nullable = false)
    private String email;               // 자연키 후보
}

@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;                    // 대리키 (Primary Key)
    
    @Column(unique = true, nullable = false)
    private String isbn;                // 비즈니스 키 (자연키 후보)
}
```

**3. 연관관계 설계**
- 양방향 vs 단방향 관계 선택
- 지연로딩 vs 즉시로딩 전략
- Cascade 옵션 신중 선택

#### 1.2.2 상세 Entity 설계 예시

```java
/**
 * 회원 Entity
 * 도서관 시스템의 회원 정보를 관리
 */
@Entity
@Table(name = "members")
public class Member {    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "member_id")
    private Long id;
    
    @Column(name = "member_number", unique = true, nullable = false, length = 10)
    @Pattern(regexp = "^M\\d{9}$", message = "회원번호는 M으로 시작하는 10자리여야 합니다")
    private String memberNumber;
    
    @Column(nullable = false, length = 50)
    @NotBlank(message = "이름은 필수입니다")
    @Size(min = 2, max = 50, message = "이름은 2-50자 사이여야 합니다")
    private String name;
    
    @Column(unique = true, nullable = false, length = 100)
    @Email(message = "올바른 이메일 형식이어야 합니다")
    private String email;
    
    @Column(name = "phone_number", length = 15)
    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "전화번호 형식이 올바르지 않습니다")
    private String phoneNumber;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private MemberStatus status = MemberStatus.ACTIVE;
    
    @Column(name = "max_loan_count")
    private Integer maxLoanCount = 5;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 연관관계
    @OneToMany(mappedBy = "member", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Loan> loans = new ArrayList<>();
    
    @OneToMany(mappedBy = "member", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Reservation> reservations = new ArrayList<>();
    
    // 비즈니스 메서드
    public boolean canLoanMore() {
        long currentLoanCount = loans.stream()
            .filter(loan -> loan.getStatus() == LoanStatus.BORROWED)
            .count();
        return currentLoanCount < maxLoanCount;
    }
    
    public boolean hasOverdueLoans() {
        return loans.stream()
            .anyMatch(loan -> loan.isOverdue());
    }
}

/**
 * 회원 상태 Enum
 */
public enum MemberStatus {
    ACTIVE("활성"),
    SUSPENDED("정지"),
    WITHDRAWN("탈퇴");
    
    private final String description;
    
    MemberStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

```java
/**
 * 도서 Entity
 */
@Entity
@Table(name = "books")
public class Book {    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "book_id")
    private Long id;
    
    @Column(nullable = false, unique = true, length = 13)
    @Pattern(regexp = "^\\d{13}$", message = "ISBN은 13자리 숫자여야 합니다")
    private String isbn;
    
    @Column(nullable = false, length = 200)
    @NotBlank(message = "제목은 필수입니다")
    @Size(max = 200, message = "제목은 200자를 초과할 수 없습니다")
    private String title;
    
    @Column(nullable = false, length = 100)
    @NotBlank(message = "저자는 필수입니다")
    private String author;
    
    @Column(length = 100)
    private String publisher;
    
    @Column(name = "publication_date")
    private LocalDate publicationDate;
    
    @Column(name = "total_copies", nullable = false)
    @Min(value = 1, message = "총 권수는 1 이상이어야 합니다")
    private Integer totalCopies;
    
    @Column(name = "available_copies", nullable = false)
    @Min(value = 0, message = "대출가능 권수는 0 이상이어야 합니다")
    private Integer availableCopies;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(name = "image_url")
    private String imageUrl;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 연관관계
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;
    
    @OneToMany(mappedBy = "book", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<Loan> loans = new ArrayList<>();
    
    // 비즈니스 메서드
    public boolean isAvailable() {
        return availableCopies > 0;
    }
    
    public void decreaseAvailableCopies() {
        if (availableCopies <= 0) {
            throw new IllegalStateException("대출 가능한 책이 없습니다");
        }
        this.availableCopies--;
    }
    
    public void increaseAvailableCopies() {
        if (availableCopies >= totalCopies) {
            throw new IllegalStateException("반납할 수 있는 책이 없습니다");
        }
        this.availableCopies++;
    }
}
```

```java
/**
 * 대출 Entity
 */
@Entity
@Table(name = "loans")
public class Loan {    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "loan_id")
    private Long id;
    
    @Column(name = "loan_number", unique = true, nullable = false, length = 12)
    private String loanNumber;
    
    @Column(name = "loan_date", nullable = false)
    private LocalDate loanDate;
    
    @Column(name = "due_date", nullable = false)
    private LocalDate dueDate;
    
    @Column(name = "return_date")
    private LocalDate returnDate;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private LoanStatus status = LoanStatus.BORROWED;
    
    @Column(name = "overdue_fee")
    private BigDecimal overdueFee = BigDecimal.ZERO;
    
    @Column(columnDefinition = "TEXT")
    private String notes;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // 연관관계
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "member_id", nullable = false)
    private Member member;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "book_id", nullable = false)
    private Book book;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approved_by")
    private Admin approvedBy;
    
    // 비즈니스 메서드
    public boolean isOverdue() {
        return status == LoanStatus.BORROWED && 
               LocalDate.now().isAfter(dueDate);
    }
    
    public long getOverdueDays() {
        if (!isOverdue()) {
            return 0;
        }
        return ChronoUnit.DAYS.between(dueDate, LocalDate.now());
    }
    
    public BigDecimal calculateOverdueFee() {
        if (!isOverdue()) {
            return BigDecimal.ZERO;
        }
        return BigDecimal.valueOf(getOverdueDays())
                .multiply(BigDecimal.valueOf(100)); // 1일당 100원
    }
    
    public void returnBook() {
        if (status != LoanStatus.BORROWED) {
            throw new IllegalStateException("대출 중인 책만 반납할 수 있습니다");
        }
        this.returnDate = LocalDate.now();
        this.status = LoanStatus.RETURNED;
        this.overdueFee = calculateOverdueFee();
        this.book.increaseAvailableCopies();
    }
}

/**
 * 대출 상태 Enum
 */
public enum LoanStatus {
    REQUESTED("신청"),
    APPROVED("승인"),
    BORROWED("대출중"),
    RETURNED("반납완료"),
    OVERDUE("연체"),
    CANCELLED("취소");
    
    private final String description;
    
    LoanStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

#### 1.2.3 Entity 설계 체크리스트

```markdown
□ 모든 Entity에 @Entity 어노테이션 적용
□ 테이블명을 명시적으로 지정 (@Table)
□ Primary Key 설정 (@Id, @GeneratedValue)
□ 컬럼명 명시적 지정 (snake_case 권장)
□ 필수 필드에 @NotNull, @NotBlank 적용
□ 문자열 길이 제한 설정 (@Size, length)
□ 유효성 검증 어노테이션 적용
□ Enum 타입 적절히 활용
□ 연관관계 매핑 정확히 설정
□ 지연로딩 설정 (성능 최적화)
□ Cascade 옵션 신중히 선택
□ 비즈니스 메서드 포함
□ 생성/수정 시간 자동 관리 (@CreatedDate, @LastModifiedDate)
□ toString, equals, hashCode 적절히 구현
```

### 1.3 Table 설계서 가이드

#### 1.3.1 테이블 설계 원칙

**1. 명명 규칙**
- 테이블명: 복수형, snake_case (예: members, loan_histories)
- 컬럼명: snake_case (예: member_id, created_at)
- 외래키: 참조테이블명_id (예: member_id, book_id)

**2. 데이터 타입 선택 기준**
```sql
-- 문자열
VARCHAR(n): 가변길이, 최대 길이 명확한 경우
TEXT: 긴 텍스트, 길이 예측 어려운 경우
CHAR(n): 고정길이, 길이가 항상 동일한 경우 (예: 국가코드)

-- 숫자
BIGINT: ID (Auto Increment)
INT: 일반적인 정수
DECIMAL(p,s): 정확한 소수점 계산 필요 (예: 금액)
FLOAT/DOUBLE: 근사치 허용하는 실수

-- 날짜/시간
DATE: 날짜만 (YYYY-MM-DD)
TIME: 시간만 (HH:MM:SS)
DATETIME: 날짜+시간
TIMESTAMP: UTC 기준 타임스탬프 (추천)

-- 불린
BOOLEAN: true/false
TINYINT(1): MySQL에서 boolean 대용
```

#### 1.3.2 상세 테이블 설계서

```sql
-- ==============================================
-- 회원 테이블 (members)
-- ==============================================
CREATE TABLE members (
    member_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '회원 ID',
    member_number VARCHAR(10) NOT NULL UNIQUE COMMENT '회원번호 (M000000001)',
    name VARCHAR(50) NOT NULL COMMENT '회원명',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '이메일',
    phone_number VARCHAR(15) COMMENT '전화번호 (010-1234-5678)',
    password VARCHAR(255) NOT NULL COMMENT '암호화된 비밀번호',
    status ENUM('ACTIVE', 'SUSPENDED', 'WITHDRAWN') NOT NULL DEFAULT 'ACTIVE' COMMENT '회원상태',
    max_loan_count INT NOT NULL DEFAULT 5 COMMENT '최대 대출 가능 권수',
    birth_date DATE COMMENT '생년월일',
    address VARCHAR(200) COMMENT '주소',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '가입일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 인덱스
    INDEX idx_member_number (member_number),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='회원 정보';

-- ==============================================
-- 카테고리 테이블 (categories)
-- ==============================================
CREATE TABLE categories (
    category_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '카테고리 ID',
    category_code VARCHAR(10) NOT NULL UNIQUE COMMENT '카테고리 코드',
    category_name VARCHAR(50) NOT NULL COMMENT '카테고리명',
    parent_category_id BIGINT COMMENT '상위 카테고리 ID',
    description TEXT COMMENT '카테고리 설명',
    sort_order INT NOT NULL DEFAULT 0 COMMENT '정렬순서',
    is_active BOOLEAN NOT NULL DEFAULT TRUE COMMENT '활성 여부',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 외래키
    FOREIGN KEY (parent_category_id) REFERENCES categories(category_id),
    
    -- 인덱스
    INDEX idx_category_code (category_code),
    INDEX idx_parent_category (parent_category_id),
    INDEX idx_sort_order (sort_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='도서 카테고리';

-- ==============================================
-- 도서 테이블 (books)
-- ==============================================
CREATE TABLE books (
    book_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '도서 ID',
    isbn VARCHAR(13) NOT NULL UNIQUE COMMENT 'ISBN (13자리)',
    title VARCHAR(200) NOT NULL COMMENT '도서명',
    author VARCHAR(100) NOT NULL COMMENT '저자',
    publisher VARCHAR(100) COMMENT '출판사',
    publication_date DATE COMMENT '출간일',
    total_copies INT NOT NULL DEFAULT 1 COMMENT '총 보유 권수',
    available_copies INT NOT NULL DEFAULT 1 COMMENT '대출 가능 권수',
    price DECIMAL(10,2) COMMENT '도서 가격',
    description TEXT COMMENT '도서 설명',
    image_url VARCHAR(500) COMMENT '표지 이미지 URL',
    page_count INT COMMENT '페이지 수',
    language VARCHAR(10) DEFAULT 'KO' COMMENT '언어 (KO, EN, etc)',
    is_active BOOLEAN NOT NULL DEFAULT TRUE COMMENT '활성 여부',
    category_id BIGINT NOT NULL COMMENT '카테고리 ID',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '등록일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 외래키
    FOREIGN KEY (category_id) REFERENCES categories(category_id),
    
    -- 인덱스
    INDEX idx_isbn (isbn),
    INDEX idx_title (title),
    INDEX idx_author (author),
    INDEX idx_category (category_id),
    INDEX idx_available (available_copies),
    FULLTEXT idx_search (title, author, description)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='도서 정보';

-- ==============================================
-- 관리자 테이블 (admins)
-- ==============================================
CREATE TABLE admins (
    admin_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '관리자 ID',
    admin_code VARCHAR(10) NOT NULL UNIQUE COMMENT '관리자 코드',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '관리자 계정',
    password VARCHAR(255) NOT NULL COMMENT '암호화된 비밀번호',
    name VARCHAR(50) NOT NULL COMMENT '관리자명',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '이메일',
    role ENUM('SUPER_ADMIN', 'ADMIN', 'LIBRARIAN') NOT NULL DEFAULT 'LIBRARIAN' COMMENT '권한',
    is_active BOOLEAN NOT NULL DEFAULT TRUE COMMENT '활성 여부',
    last_login_at TIMESTAMP COMMENT '마지막 로그인 시간',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 인덱스
    INDEX idx_username (username),
    INDEX idx_role (role),
    INDEX idx_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='관리자 정보';

-- ==============================================
-- 대출 테이블 (loans)
-- ==============================================
CREATE TABLE loans (
    loan_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '대출 ID',
    loan_number VARCHAR(12) NOT NULL UNIQUE COMMENT '대출번호 (L202505230001)',
    member_id BIGINT NOT NULL COMMENT '회원 ID',
    book_id BIGINT NOT NULL COMMENT '도서 ID',
    loan_date DATE NOT NULL COMMENT '대출일',
    due_date DATE NOT NULL COMMENT '반납예정일',
    return_date DATE COMMENT '실제반납일',
    status ENUM('REQUESTED', 'APPROVED', 'BORROWED', 'RETURNED', 'OVERDUE', 'CANCELLED') 
        NOT NULL DEFAULT 'REQUESTED' COMMENT '대출상태',
    overdue_fee DECIMAL(10,2) NOT NULL DEFAULT 0.00 COMMENT '연체료',
    notes TEXT COMMENT '비고',
    approved_by BIGINT COMMENT '승인한 관리자 ID',
    approved_at TIMESTAMP COMMENT '승인일시',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '신청일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 외래키
    FOREIGN KEY (member_id) REFERENCES members(member_id),
    FOREIGN KEY (book_id) REFERENCES books(book_id),
    FOREIGN KEY (approved_by) REFERENCES admins(admin_id),
    
    -- 인덱스
    INDEX idx_loan_number (loan_number),
    INDEX idx_member_id (member_id),
    INDEX idx_book_id (book_id),
    INDEX idx_status (status),
    INDEX idx_loan_date (loan_date),
    INDEX idx_due_date (due_date),
    INDEX idx_return_date (return_date),
    
    -- 복합 인덱스
    INDEX idx_member_status (member_id, status),
    INDEX idx_book_status (book_id, status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='도서 대출 정보';

-- ==============================================
-- 예약 테이블 (reservations)
-- ==============================================
CREATE TABLE reservations (
    reservation_id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '예약 ID',
    reservation_number VARCHAR(12) NOT NULL UNIQUE COMMENT '예약번호 (R202505230001)',
    member_id BIGINT NOT NULL COMMENT '회원 ID',
    book_id BIGINT NOT NULL COMMENT '도서 ID',
    reservation_date DATE NOT NULL COMMENT '예약일',
    expiry_date DATE NOT NULL COMMENT '예약만료일',
    status ENUM('ACTIVE', 'COMPLETED', 'CANCELLED', 'EXPIRED') 
        NOT NULL DEFAULT 'ACTIVE' COMMENT '예약상태',
    priority_order INT NOT NULL COMMENT '예약순서',
    notes TEXT COMMENT '비고',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '예약일시',
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
    
    -- 외래키
    FOREIGN KEY (member_id) REFERENCES members(member_id),
    FOREIGN KEY (book_id) REFERENCES books(book_id),
    
    -- 인덱스
    INDEX idx_reservation_number (reservation_number),
    INDEX idx_member_id (member_id),
    INDEX idx_book_id (book_id),
    INDEX idx_status (status),
    INDEX idx_priority (book_id, priority_order),
    
    -- 유니크 제약조건 (한 회원이 같은 책을 중복 예약 불가)
    UNIQUE KEY uk_member_book_active (member_id, book_id, status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='도서 예약 정보';
```

#### 1.3.3 초기 데이터 스크립트

```sql
-- ==============================================
-- 초기 데이터 INSERT
-- ==============================================

-- 관리자 데이터 (비밀번호는 모두 'admin123!')
INSERT INTO admins (admin_code, username, password, name, email, role) VALUES
('ADM001', 'superadmin', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '슈퍼관리자', 'super@library.com', 'SUPER_ADMIN'),
('ADM002', 'admin1', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '일반관리자', 'admin1@library.com', 'ADMIN'),
('ADM003', 'librarian1', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '사서1', 'lib1@library.com', 'LIBRARIAN');

-- 카테고리 데이터
INSERT INTO categories (category_code, category_name, parent_category_id, description, sort_order) VALUES
('FIC', '소설/문학', NULL, '소설, 시, 수필 등 문학 작품', 1),
('SCI', '과학/기술', NULL, '과학, 공학, 기술 관련 도서', 2),
('HIS', '역사/문화', NULL, '역사, 문화, 사회 관련 도서', 3),
('EDU', '교육/학습', NULL, '교육, 학습서, 참고서', 4),
('BUS', '경영/경제', NULL, '경영학, 경제학, 자기계발서', 5),
('ART', '예술/취미', NULL, '미술, 음악, 스포츠, 취미', 6),
('CHI', '아동/청소년', NULL, '아동서, 청소년 소설', 7);

-- 하위 카테고리
INSERT INTO categories (category_code, category_name, parent_category_id, description, sort_order) VALUES
('FIC001', '한국소설', 1, '한국 작가의 소설', 1),
('FIC002', '외국소설', 1, '외국 작가의 번역소설', 2),
('FIC003', '시/수필', 1, '시집, 수필집', 3),
('SCI001', '컴퓨터/IT', 2, '프로그래밍, 컴퓨터 과학', 1),
('SCI002', '자연과학', 2, '물리, 화학, 생물학', 2),
('EDU001', '대학교재', 4, '대학 전공 교재', 1),
('EDU002', '자격증/시험', 4, '자격증, 공무원 시험서', 2);

-- 회원 데이터
INSERT INTO members (member_number, name, email, phone_number, password, birth_date, address) VALUES
('M000000001', '김철수', 'kim@email.com', '010-1234-5678', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '1990-05-15', '서울시 강남구'),
('M000000002', '이영희', 'lee@email.com', '010-2345-6789', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '1988-12-03', '서울시 서초구'),
('M000000003', '박민수', 'park@email.com', '010-3456-7890', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '1995-08-22', '경기도 성남시'),
('M000000004', '최지은', 'choi@email.com', '010-4567-8901', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '1992-01-10', '서울시 마포구'),
('M000000005', '정태영', 'jung@email.com', '010-5678-9012', '$2a$10$N.zmdr9k7uOkXfvjjYGZUeU4ggq0N8A3C1J3YhzTF.7x4HgqW6XyK', '1987-07-08', '인천시 연수구');

-- 도서 데이터
INSERT INTO books (isbn, title, author, publisher, publication_date, total_copies, available_copies, price, description, category_id) VALUES
('9788932917245', '82년생 김지영', '조남주', '민음사', '2016-10-14', 3, 2, 13800.00, '한국 여성의 현실을 그린 베스트셀러 소설', 8),
('9788954655842', '코스모스', '칼 세이건', '사이언스북스', '2006-12-20', 2, 2, 17000.00, '우주와 과학에 대한 경이로운 이야기', 11),
('9788960512085', '사피엔스', '유발 하라리', '김영사', '2015-11-02', 5, 4, 19800.00, '인류 역사에 대한 통찰력 있는 분석', 3),
('9788968480508', '클린 코드', '로버트 C. 마틴', '인사이트', '2013-12-24', 4, 3, 33000.00, '깨끗한 코드 작성법', 10),
('9788932473901', '어린왕자', '생텍쥐페리', '문학동네', '2015-05-20', 6, 5, 9000.00, '전 세계가 사랑하는 동화', 7),
('9788937460777', '1984', '조지 오웰', '민음사', '2003-04-10', 3, 3, 12000.00, '전체주의 사회를 그린 디스토피아 소설', 9),
('9788932916712', 'Java의 정석', '남궁성', '도우출판', '2022-01-15', 8, 7, 35000.00, 'Java 프로그래밍 완벽 가이드', 10),
('9788956746425', '총균쇠', '재레드 다이아몬드', '문학사상', '2005-12-15', 2, 1, 25000.00, '인류 문명 발달의 비밀', 3),
('9788934942467', '미움받을 용기', '기시미 이치로', '인플루엔셜', '2014-11-17', 4, 4, 14900.00, '아들러 심리학을 바탕으로 한 자기계발서', 5),
('9788952778123', '설민석의 조선왕조실록', '설민석', '세계사', '2016-06-20', 3, 2, 19800.00, '조선 500년 역사를 재미있게 풀어낸 책', 3);

-- 대출 데이터 (일부는 반납완료, 일부는 대출중, 일부는 연체)
INSERT INTO loans (loan_number, member_id, book_id, loan_date, due_date, return_date, status, approved_by, approved_at) VALUES
('L202505010001', 1, 1, '2025-05-01', '2025-05-15', '2025-05-13', 'RETURNED', 1, '2025-05-01 09:00:00'),
('L202505050002', 2, 2, '2025-05-05', '2025-05-19', NULL, 'BORROWED', 1, '2025-05-05 10:30:00'),
('L202505100003', 3, 4, '2025-05-10', '2025-05-24', NULL, 'BORROWED', 2, '2025-05-10 14:20:00'),
('L202505150004', 1, 3, '2025-05-15', '2025-05-29', NULL, 'BORROWED', 1, '2025-05-15 11:45:00'),
('L202505200005', 4, 7, '2025-05-20', '2025-06-03', NULL, 'BORROWED', 3, '2025-05-20 16:10:00'),
('L202505010006', 5, 8, '2025-05-01', '2025-05-15', NULL, 'OVERDUE', 1, '2025-05-01 13:00:00'),
('L202505080007', 2, 5, '2025-05-08', '2025-05-22', '2025-05-20', 'RETURNED', 2, '2025-05-08 09:30:00');

-- 예약 데이터
INSERT INTO reservations (reservation_number, member_id, book_id, reservation_date, expiry_date, status, priority_order) VALUES
('R202505220001', 3, 1, '2025-05-22', '2025-05-25', 'ACTIVE', 1),
('R202505220002', 4, 1, '2025-05-22', '2025-05-25', 'ACTIVE', 2),
('R202505230003', 5, 8, '2025-05-23', '2025-05-26', 'ACTIVE', 1);
```

#### 1.3.4 테이블 설계 검증 쿼리

```sql
-- ==============================================
-- 테이블 설계 검증용 쿼리
-- ==============================================

-- 1. 회원별 현재 대출 현황
SELECT 
    m.name AS 회원명,
    COUNT(l.loan_id) AS 대출중인_책수,
    m.max_loan_count AS 최대대출가능수,
    (m.max_loan_count - COUNT(l.loan_id)) AS 추가대출가능수
FROM members m
LEFT JOIN loans l ON m.member_id = l.member_id 
    AND l.status = 'BORROWED'
WHERE m.status = 'ACTIVE'
GROUP BY m.member_id, m.name, m.max_loan_count;

-- 2. 도서별 대출 통계
SELECT 
    b.title AS 도서명,
    b.total_copies AS 총보유수,
    b.available_copies AS 대출가능수,
    COUNT(l.loan_id) AS 총대출횟수,
    COUNT(CASE WHEN l.status = 'BORROWED' THEN 1 END) AS 현재대출중
FROM books b
LEFT JOIN loans l ON b.book_id = l.book_id
GROUP BY b.book_id, b.title, b.total_copies, b.available_copies
ORDER BY 총대출횟수 DESC;

-- 3. 연체 현황
SELECT 
    m.name AS 회원명,
    b.title AS 도서명,
    l.loan_date AS 대출일,
    l.due_date AS 반납예정일,
    DATEDIFF(CURDATE(), l.due_date) AS 연체일수,
    (DATEDIFF(CURDATE(), l.due_date) * 100) AS 연체료
FROM loans l
JOIN members m ON l.member_id = m.member_id
JOIN books b ON l.book_id = b.book_id
WHERE l.status = 'BORROWED' 
    AND l.due_date < CURDATE()
ORDER BY 연체일수 DESC;

-- 4. 인기 도서 TOP 10
SELECT 
    b.title AS 도서명,
    b.author AS 저자,
    c.category_name AS 카테고리,
    COUNT(l.loan_id) AS 대출횟수
FROM books b
JOIN categories c ON b.category_id = c.category_id
LEFT JOIN loans l ON b.book_id = l.book_id
GROUP BY b.book_id, b.title, b.author, c.category_name
ORDER BY 대출횟수 DESC
LIMIT 10;
```

### 1.4 REST API 설계서 가이드

#### 1.4.1 REST API 설계 원칙

**1. RESTful URL 설계 원칙**
```
자원(Resource) 중심 설계:
- 좋은 예: GET /api/books, POST /api/members
- 나쁜 예: GET /api/getBooks, POST /api/createMember

HTTP 메서드 적절한 사용:
- GET: 조회 (안전하고 멱등)
- POST: 생성 (안전하지 않고 멱등하지 않음)
- PUT: 전체 수정 (안전하지 않지만 멱등)
- PATCH: 부분 수정 (안전하지 않고 멱등하지 않음)
- DELETE: 삭제 (안전하지 않지만 멱등)

계층적 URL 구조:
- /api/books/{bookId}/loans - 특정 도서의 대출 목록
- /api/members/{memberId}/reservations - 특정 회원의 예약 목록

쿼리 파라미터 활용:
- 필터링: /api/books?category=fiction&author=김작가
- 정렬: /api/books?sort=title&order=asc
- 페이징: /api/books?page=1&size=20
```

**2. HTTP 상태 코드 가이드**
```
성공 응답:
- 200 OK: 일반적인 성공
- 201 Created: 리소스 생성 성공
- 204 No Content: 성공했지만 응답 본문 없음 (DELETE)

클라이언트 에러:
- 400 Bad Request: 잘못된 요청 (검증 실패)
- 401 Unauthorized: 인증 필요
- 403 Forbidden: 권한 없음
- 404 Not Found: 리소스 없음
- 409 Conflict: 중복 등 비즈니스 규칙 위반

서버 에러:
- 500 Internal Server Error: 서버 내부 오류
```

#### 1.4.2 상세 API 명세서

**회원 관리 API**

```yaml
# 회원 목록 조회
GET /api/members
Parameters:
  - page: int (기본값: 0) - 페이지 번호
  - size: int (기본값: 20) - 페이지 크기
  - status: string - 회원 상태 필터 (ACTIVE, SUSPENDED, WITHDRAWN)
  - search: string - 검색어 (이름, 이메일)
  - sort: string (기본값: createdAt) - 정렬 기준
  - order: string (기본값: desc) - 정렬 순서 (asc, desc)

Response (200 OK):
{
  "content": [
    {
      "id": 1,
      "memberNumber": "M000000001",
      "name": "김철수",
      "email": "kim@email.com",
      "phoneNumber": "010-1234-5678",
      "status": "ACTIVE",
      "maxLoanCount": 5,
      "currentLoanCount": 2,
      "createdAt": "2025-05-01T10:30:00",
      "updatedAt": "2025-05-20T15:20:00"
    }
  ],
  "pageable": {
    "page": 0,
    "size": 20,
    "sort": "createdAt,desc"
  },
  "totalElements": 150,
  "totalPages": 8,
  "first": true,
  "last": false
}

# 회원 상세 조회
GET /api/members/{memberId}
Response (200 OK):
{
  "id": 1,
  "memberNumber": "M000000001",
  "name": "김철수",
  "email": "kim@email.com",
  "phoneNumber": "010-1234-5678",
  "status": "ACTIVE",
  "maxLoanCount": 5,
  "birthDate": "1990-05-15",
  "address": "서울시 강남구",
  "createdAt": "2025-05-01T10:30:00",
  "updatedAt": "2025-05-20T15:20:00",
  "loanHistory": {
    "totalLoans": 15,
    "currentLoans": 2,
    "overdueCount": 0
  }
}

Response (404 Not Found):
{
  "error": "MEMBER_NOT_FOUND",
  "message": "회원을 찾을 수 없습니다",
  "timestamp": "2025-05-23T10:30:00"
}

# 회원 등록
POST /api/members
Content-Type: application/json

Request Body:
{
  "name": "김철수",
  "email": "kim@email.com",
  "phoneNumber": "010-1234-5678",
  "password": "password123!",
  "birthDate": "1990-05-15",
  "address": "서울시 강남구"
}

Response (201 Created):
{
  "id": 1,
  "memberNumber": "M000000001",
  "name": "김철수",
  "email": "kim@email.com",
  "phoneNumber": "010-1234-5678",
  "status": "ACTIVE",
  "maxLoanCount": 5,
  "createdAt": "2025-05-23T10:30:00"
}

Response (400 Bad Request):
{
  "error": "VALIDATION_ERROR",
  "message": "입력값이 올바르지 않습니다",
  "fieldErrors": [
    {
      "field": "email",
      "message": "이미 사용 중인 이메일입니다"
    },
    {
      "field": "phoneNumber",
      "message": "전화번호 형식이 올바르지 않습니다"
    }
  ],
  "timestamp": "2025-05-23T10:30:00"
}

# 회원 정보 수정
PUT /api/members/{memberId}
Content-Type: application/json

Request Body:
{
  "name": "김철수",
  "phoneNumber": "010-1234-5679",
  "address": "서울시 서초구"
}

Response (200 OK):
{
  "id": 1,
  "memberNumber": "M000000001",
  "name": "김철수",
  "email": "kim@email.com",
  "phoneNumber": "010-1234-5679",
  "status": "ACTIVE",
  "address": "서울시 서초구",
  "updatedAt": "2025-05-23T10:30:00"
}

# 회원 상태 변경
PATCH /api/members/{memberId}/status
Content-Type: application/json

Request Body:
{
  "status": "SUSPENDED",
  "reason": "연체료 미납으로 인한 정지"
}

Response (200 OK):
{
  "id": 1,
  "status": "SUSPENDED",
  "updatedAt": "2025-05-23T10:30:00"
}
```

**도서 관리 API**

```yaml
# 도서 목록 조회
GET /api/books
Parameters:
  - page: int (기본값: 0)
  - size: int (기본값: 20)
  - category: long - 카테고리 ID
  - search: string - 검색어 (제목, 저자, ISBN)
  - available: boolean - 대출 가능 여부
  - sort: string (기본값: title) - 정렬 기준
  - order: string (기본값: asc) - 정렬 순서

Response (200 OK):
{
  "content": [
    {
      "id": 1,
      "isbn": "9788932917245",
      "title": "82년생 김지영",
      "author": "조남주",
      "publisher": "민음사",
      "publicationDate": "2016-10-14",
      "totalCopies": 3,
      "availableCopies": 2,
      "price": 13800.00,
      "imageUrl": "https://example.com/book1.jpg",
      "category": {
        "id": 8,
        "name": "한국소설"
      },
      "isAvailable": true
    }
  ],
  "pageable": {
    "page": 0,
    "size": 20
  },
  "totalElements": 500,
  "totalPages": 25
}

# 도서 상세 조회
GET /api/books/{bookId}
Response (200 OK):
{
  "id": 1,
  "isbn": "9788932917245",
  "title": "82년생 김지영",
  "author": "조남주",
  "publisher": "민음사",
  "publicationDate": "2016-10-14",
  "totalCopies": 3,
  "availableCopies": 2,
  "price": 13800.00,
  "description": "한국 여성의 현실을 그린 베스트셀러 소설",
  "imageUrl": "https://example.com/book1.jpg",
  "pageCount": 215,
  "language": "KO",
  "category": {
    "id": 8,
    "name": "한국소설",
    "parentCategory": {
      "id": 1,
      "name": "소설/문학"
    }
  },
  "loanStats": {
    "totalLoans": 25,
    "currentLoans": 1,
    "reservationCount": 2
  },
  "isAvailable": true
}

# 도서 등록
POST /api/books
Content-Type: application/json

Request Body:
{
  "isbn": "9788932917245",
  "title": "82년생 김지영",
  "author": "조남주",
  "publisher": "민음사",
  "publicationDate": "2016-10-14",
  "totalCopies": 3,
  "price": 13800.00,
  "description": "한국 여성의 현실을 그린 베스트셀러 소설",
  "categoryId": 8,
  "pageCount": 215,
  "language": "KO"
}

Response (201 Created):
{
  "id": 1,
  "isbn": "9788932917245",
  "title": "82년생 김지영",
  "author": "조남주",
  "totalCopies": 3,
  "availableCopies": 3,
  "createdAt": "2025-05-23T10:30:00"
}

Response (409 Conflict):
{
  "error": "DUPLICATE_ISBN",
  "message": "이미 등록된 ISBN입니다",
  "timestamp": "2025-05-23T10:30:00"
}
```

**대출 관리 API**

```yaml
# 대출 신청
POST /api/loans
Content-Type: application/json
Authorization: Bearer {JWT_TOKEN}

Request Body:
{
  "bookId": 1,
  "memberId": 1,
  "notes": "급하게 필요한 도서입니다"
}

Response (201 Created):
{
  "id": 1,
  "loanNumber": "L202505230001",
  "member": {
    "id": 1,
    "name": "김철수",
    "memberNumber": "M000000001"
  },
  "book": {
    "id": 1,
    "title": "82년생 김지영",
    "isbn": "9788932917245"
  },
  "loanDate": "2025-05-23",
  "dueDate": "2025-06-06",
  "status": "REQUESTED",
  "createdAt": "2025-05-23T10:30:00"
}

Response (400 Bad Request):
{
  "error": "LOAN_NOT_AVAILABLE",
  "message": "대출이 불가능합니다",
  "details": [
    "회원의 최대 대출 권수를 초과했습니다",
    "연체 중인 도서가 있습니다"
  ],
  "timestamp": "2025-05-23T10:30:00"
}

# 대출 승인
PATCH /api/loans/{loanId}/approve
Content-Type: application/json
Authorization: Bearer {ADMIN_JWT_TOKEN}

Request Body:
{
  "notes": "승인 완료"
}

Response (200 OK):
{
  "id": 1,
  "loanNumber": "L202505230001",
  "status": "APPROVED",
  "approvedBy": {
    "id": 1,
    "name": "관리자1"
  },
  "approvedAt": "2025-05-23T10:35:00",
  "updatedAt": "2025-05-23T10:35:00"
}

# 도서 반납
PATCH /api/loans/{loanId}/return
Content-Type: application/json
Authorization: Bearer {ADMIN_JWT_TOKEN}

Response (200 OK):
{
  "id": 1,
  "loanNumber": "L202505230001",
  "status": "RETURNED",
  "returnDate": "2025-05-23",
  "overdueFee": 0.00,
  "isOverdue": false,
  "updatedAt": "2025-05-23T10:40:00"
}

Response (400 Bad Request):
{
  "error": "INVALID_LOAN_STATUS",
  "message": "반납할 수 없는 상태입니다",
  "currentStatus": "REQUESTED",
  "timestamp": "2025-05-23T10:40:00"
}

# 대출 목록 조회
GET /api/loans
Parameters:
  - page: int (기본값: 0)
  - size: int (기본값: 20)
  - memberId: long - 회원 ID 필터
  - bookId: long - 도서 ID 필터
  - status: string - 상태 필터
  - overdue: boolean - 연체 여부 필터
  - fromDate: date - 대출일 시작일
  - toDate: date - 대출일 종료일

Response (200 OK):
{
  "content": [
    {
      "id": 1,
      "loanNumber": "L202505230001",
      "member": {
        "id": 1,
        "name": "김철수",
        "memberNumber": "M000000001"
      },
      "book": {
        "id": 1,
        "title": "82년생 김지영",
        "author": "조남주"
      },
      "loanDate": "2025-05-23",
      "dueDate": "2025-06-06",
      "returnDate": null,
      "status": "BORROWED",
      "overdueFee": 0.00,
      "isOverdue": false,
      "overdueDays": 0
    }
  ],
  "pageable": {
    "page": 0,
    "size": 20
  },
  "totalElements": 100
}
```

#### 1.4.3 API 공통 응답 형식

```json
// 성공 응답 (단일 객체)
{
  "success": true,
  "data": {
    // 실제 데이터
  },
  "timestamp": "2025-05-23T10:30:00"
}

// 성공 응답 (목록)
{
  "success": true,
  "data": {
    "content": [
      // 데이터 배열
    ],
    "pageable": {
      "page": 0,
      "size": 20,
      "sort": "createdAt,desc"
    },
    "totalElements": 100,
    "totalPages": 5,
    "first": true,
    "last": false
  },
  "timestamp": "2025-05-23T10:30:00"
}

// 에러 응답
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력값이 올바르지 않습니다",
    "details": [
      {
        "field": "email",
        "message": "이메일 형식이 올바르지 않습니다"
      }
    ]
  },
  "timestamp": "2025-05-23T10:30:00"
}
```

#### 1.4.4 인증 및 권한 API

```yaml
# 로그인 (회원)
POST /api/auth/login
Content-Type: application/json

Request Body:
{
  "email": "kim@email.com",
  "password": "password123!"
}

Response (200 OK):
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "user": {
      "id": 1,
      "name": "김철수",
      "email": "kim@email.com",
      "memberNumber": "M000000001",
      "role": "MEMBER"
    }
  }
}

Response (401 Unauthorized):
{
  "success": false,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "이메일 또는 비밀번호가 올바르지 않습니다"
  }
}

# 관리자 로그인
POST /api/admin/auth/login
Content-Type: application/json

Request Body:
{
  "username": "admin1",
  "password": "admin123!"
}

Response (200 OK):
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "admin": {
      "id": 1,
      "username": "admin1",
      "name": "일반관리자",
      "role": "ADMIN"
    }
  }
}

# 토큰 갱신
POST /api/auth/refresh
Content-Type: application/json

Request Body:
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Response (200 OK):
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 3600
  }
}

# 로그아웃
POST /api/auth/logout
Authorization: Bearer {JWT_TOKEN}

Response (204 No Content)

# 내 정보 조회
GET /api/auth/me
Authorization: Bearer {JWT_TOKEN}

Response (200 OK):
{
  "success": true,
  "data": {
    "id": 1,
    "name": "김철수",
    "email": "kim@email.com",
    "memberNumber": "M000000001",
    "status": "ACTIVE",
    "currentLoanCount": 2,
    "maxLoanCount": 5
  }
}
```

### 1.5 에러 코드 관리 가이드

#### 1.5.1 에러 코드 체계 설계

**1. 에러 코드 명명 규칙**
```
형식: [도메인]_[상세분류]_[순번]
예시:
- AUTH_INVALID_CREDENTIALS: 인증 실패
- MEMBER_NOT_FOUND: 회원 없음
- BOOK_NOT_AVAILABLE: 도서 대출 불가
- LOAN_EXCEED_LIMIT: 대출 한도 초과
```

**2. HTTP 상태 코드 매핑**
```java
public enum ErrorCode {
    // 인증/인가 관련 (40X)
    AUTH_INVALID_CREDENTIALS("AUTH_001", "이메일 또는 비밀번호가 올바르지 않습니다", HttpStatus.UNAUTHORIZED),
    AUTH_TOKEN_EXPIRED("AUTH_002", "토큰이 만료되었습니다", HttpStatus.UNAUTHORIZED),
    AUTH_TOKEN_INVALID("AUTH_003", "유효하지 않은 토큰입니다", HttpStatus.UNAUTHORIZED),
    AUTH_ACCESS_DENIED("AUTH_004", "접근 권한이 없습니다", HttpStatus.FORBIDDEN),
    AUTH_ACCOUNT_LOCKED("AUTH_005", "계정이 잠겨있습니다", HttpStatus.FORBIDDEN),
    
    // 회원 관련 (40X)
    MEMBER_NOT_FOUND("MEMBER_001", "회원을 찾을 수 없습니다", HttpStatus.NOT_FOUND),
    MEMBER_EMAIL_DUPLICATE("MEMBER_002", "이미 사용 중인 이메일입니다", HttpStatus.CONFLICT),
    MEMBER_SUSPENDED("MEMBER_003", "정지된 회원입니다", HttpStatus.FORBIDDEN),
    MEMBER_WITHDRAWN("MEMBER_004", "탈퇴한 회원입니다", HttpStatus.GONE),
    
    // 도서 관련 (40X)
    BOOK_NOT_FOUND("BOOK_001", "도서를 찾을 수 없습니다", HttpStatus.NOT_FOUND),
    BOOK_ISBN_DUPLICATE("BOOK_002", "이미 등록된 ISBN입니다", HttpStatus.CONFLICT),
    BOOK_NOT_AVAILABLE("BOOK_003", "대출할 수 없는 도서입니다", HttpStatus.BAD_REQUEST),
    BOOK_OUT_OF_STOCK("BOOK_004", "재고가 없습니다", HttpStatus.BAD_REQUEST),
    
    // 대출 관련 (40X)
    LOAN_NOT_FOUND("LOAN_001", "대출 정보를 찾을 수 없습니다", HttpStatus.NOT_FOUND),
    LOAN_EXCEED_LIMIT("LOAN_002", "최대 대출 권수를 초과했습니다", HttpStatus.BAD_REQUEST),
    LOAN_MEMBER_OVERDUE("LOAN_003", "연체 중인 도서가 있어 대출할 수 없습니다", HttpStatus.BAD_REQUEST),
    LOAN_ALREADY_BORROWED("LOAN_004", "이미 대출 중인 도서입니다", HttpStatus.CONFLICT),
    LOAN_INVALID_STATUS("LOAN_005", "잘못된 대출 상태입니다", HttpStatus.BAD_REQUEST),
    LOAN_CANNOT_RETURN("LOAN_006", "반납할 수 없는 상태입니다", HttpStatus.BAD_REQUEST),
    
    // 예약 관련 (40X)
    RESERVATION_NOT_FOUND("RESERVATION_001", "예약 정보를 찾을 수 없습니다", HttpStatus.NOT_FOUND),
    RESERVATION_DUPLICATE("RESERVATION_002", "이미 예약한 도서입니다", HttpStatus.CONFLICT),
    RESERVATION_LIMIT_EXCEEDED("RESERVATION_003", "예약 한도를 초과했습니다", HttpStatus.BAD_REQUEST),
    
    // 카테고리 관련 (40X)
    CATEGORY_NOT_FOUND("CATEGORY_001", "카테고리를 찾을 수 없습니다", HttpStatus.NOT_FOUND),
    CATEGORY_HAS_BOOKS("CATEGORY_002", "도서가 등록된 카테고리는 삭제할 수 없습니다", HttpStatus.CONFLICT),
    
    // 검증 관련 (40X)
    VALIDATION_ERROR("VALID_001", "입력값이 올바르지 않습니다", HttpStatus.BAD_REQUEST),
    REQUIRED_FIELD_MISSING("VALID_002", "필수 항목이 누락되었습니다", HttpStatus.BAD_REQUEST),
    INVALID_FORMAT("VALID_003", "형식이 올바르지 않습니다", HttpStatus.BAD_REQUEST),
    
    // 비즈니스 로직 관련 (40X)
    BUSINESS_RULE_VIOLATION("BIZ_001", "비즈니스 규칙 위반입니다", HttpStatus.BAD_REQUEST),
    OPERATION_NOT_ALLOWED("BIZ_002", "허용되지 않은 작업입니다", HttpStatus.BAD_REQUEST),
    
    // 서버 오류 (50X)
    INTERNAL_SERVER_ERROR("SERVER_001", "서버 내부 오류가 발생했습니다", HttpStatus.INTERNAL_SERVER_ERROR),
    DATABASE_ERROR("SERVER_002", "데이터베이스 오류가 발생했습니다", HttpStatus.INTERNAL_SERVER_ERROR),
    EXTERNAL_API_ERROR("SERVER_003", "외부 API 호출 중 오류가 발생했습니다", HttpStatus.BAD_GATEWAY);

    private final String code;
    private final String message;
    private final HttpStatus httpStatus;

    ErrorCode(String code, String message, HttpStatus httpStatus) {
        this.code = code;
        this.message = message;
        this.httpStatus = httpStatus;
    }

    // getters...
}
```

#### 1.5.2 예외 처리 클래스 구조

```java
/**
 * 기본 비즈니스 예외 클래스
 */
public class BusinessException extends RuntimeException {
    private final ErrorCode errorCode;
    private final String detail;

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
        this.detail = null;
    }

    public BusinessException(ErrorCode errorCode, String detail) {
        super(errorCode.getMessage());
        this.errorCode = errorCode;
        this.detail = detail;
    }

    public BusinessException(ErrorCode errorCode, String detail, Throwable cause) {
        super(errorCode.getMessage(), cause);
        this.errorCode = errorCode;
        this.detail = detail;
    }

    // getters...
}

/**
 * 검증 예외 클래스
 */
public class ValidationException extends BusinessException {
    private final List<FieldError> fieldErrors;

    public ValidationException(List<FieldError> fieldErrors) {
        super(ErrorCode.VALIDATION_ERROR);
        this.fieldErrors = fieldErrors;
    }

    public static class FieldError {
        private final String field;
        private final String message;
        private final Object rejectedValue;

        // constructors, getters...
    }
}

/**
 * 엔티티 없음 예외 클래스
 */
public class EntityNotFoundException extends BusinessException {
    public EntityNotFoundException(String entityName, Object identifier) {
        super(ErrorCode.valueOf(entityName.toUpperCase() + "_NOT_FOUND"), 
              String.format("%s를 찾을 수 없습니다. ID: %s", entityName, identifier));
    }
}
```

#### 1.5.3 글로벌 예외 처리기

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 비즈니스 예외 처리
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        log.warn("Business exception: {}", e.getMessage(), e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(e.getErrorCode().getCode())
                        .message(e.getErrorCode().getMessage())
                        .detail(e.getDetail())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(e.getErrorCode().getHttpStatus()).body(errorResponse);
    }

    /**
     * 검증 예외 처리
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException e) {
        log.warn("Validation exception: {}", e.getMessage());
        
        List<ErrorResponse.FieldError> fieldErrors = e.getFieldErrors().stream()
                .map(fieldError -> ErrorResponse.FieldError.builder()
                        .field(fieldError.getField())
                        .message(fieldError.getMessage())
                        .rejectedValue(fieldError.getRejectedValue())
                        .build())
                .collect(Collectors.toList());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(e.getErrorCode().getCode())
                        .message(e.getErrorCode().getMessage())
                        .fieldErrors(fieldErrors)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    /**
     * Spring Validation 예외 처리
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        log.warn("Validation exception: {}", e.getMessage());
        
        List<ErrorResponse.FieldError> fieldErrors = e.getBindingResult().getFieldErrors().stream()
                .map(fieldError -> ErrorResponse.FieldError.builder()
                        .field(fieldError.getField())
                        .message(fieldError.getDefaultMessage())
                        .rejectedValue(fieldError.getRejectedValue())
                        .build())
                .collect(Collectors.toList());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(ErrorCode.VALIDATION_ERROR.getCode())
                        .message(ErrorCode.VALIDATION_ERROR.getMessage())
                        .fieldErrors(fieldErrors)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.badRequest().body(errorResponse);
    }

    /**
     * 엔티티 없음 예외 처리
     */
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFoundException(EntityNotFoundException e) {
        log.warn("Entity not found: {}", e.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(e.getErrorCode().getCode())
                        .message(e.getErrorCode().getMessage())
                        .detail(e.getDetail())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }

    /**
     * 접근 거부 예외 처리
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(AccessDeniedException e) {
        log.warn("Access denied: {}", e.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(ErrorCode.AUTH_ACCESS_DENIED.getCode())
                        .message(ErrorCode.AUTH_ACCESS_DENIED.getMessage())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
    }

    /**
     * 일반 예외 처리
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception e) {
        log.error("Unexpected error: {}", e.getMessage(), e);
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .error(ErrorResponse.ErrorDetail.builder()
                        .code(ErrorCode.INTERNAL_SERVER_ERROR.getCode())
                        .message(ErrorCode.INTERNAL_SERVER_ERROR.getMessage())
                        .build())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}

/**
 * 에러 응답 DTO
 */
@Data
@Builder
public class ErrorResponse {
    private boolean success;
    private ErrorDetail error;
    private LocalDateTime timestamp;

    @Data
    @Builder
    public static class ErrorDetail {
        private String code;
        private String message;
        private String detail;
        private List<FieldError> fieldErrors;
    }

    @Data
    @Builder
    public static class FieldError {
        private String field;
        private String message;
        private Object rejectedValue;
    }
}
```

#### 1.5.4 로깅 전략

```yaml
# application.yml
logging:
  level:
    com.library: DEBUG
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%logger{36}:%line] - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%logger{36}:%line] - %msg%n"
  file:
    name: logs/library-system.log
    max-size: 10MB
    max-history: 30
```

```java
/**
 * 로깅 유틸리티 클래스
 */
@Component
@Slf4j
public class LoggingUtils {
    
    public static void logApiRequest(String method, String url, Object requestBody) {
        log.info("API Request - {} {} | Body: {}", method, url, 
                requestBody != null ? JsonUtils.toJson(requestBody) : "N/A");
    }
    
    public static void logApiResponse(String method, String url, int statusCode, Object responseBody) {
        log.info("API Response - {} {} | Status: {} | Body: {}", method, url, statusCode,
                responseBody != null ? JsonUtils.toJson(responseBody) : "N/A");
    }
    
    public static void logBusinessError(String operation, String error, Object context) {
        log.warn("Business Error - Operation: {} | Error: {} | Context: {}", 
                operation, error, JsonUtils.toJson(context));
    }
    
    public static void logSystemError(String operation, Exception e, Object context) {
        log.error("System Error - Operation: {} | Context: {} | Error: {}", 
                operation, JsonUtils.toJson(context), e.getMessage(), e);
    }
}
```

---
